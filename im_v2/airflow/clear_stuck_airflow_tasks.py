#!/usr/bin/env python
"""
Script to find any DAG runs longer than a desired threshold and clear their
tasks to resume DAG scheduling and clear workers. Base script adapted from:
https://docs.aws.amazon.com/mwaa/latest/userguide/call-mwaa-apis-cli.html.

Use as:

> im_v2/airflow/clear_stuck_airflow_tasks.py \
    --mwaa_environment 'Crypto_Airflow' \
    --dag_duration_threshold '210' \
    --test
"""

import argparse
import base64
import datetime
import json
import logging
from typing import Dict, List

import boto3
import requests
from botocore.client import BaseClient  # type: ignore[import]

import helpers.hdbg as hdbg
import helpers.hparser as hparser


def _get_mwaa_client(*, aws_profile: str = "ck") -> BaseClient:
    """
    Return client to work with AWS MWAA in the specified region.
    """
    hdbg.dassert_isinstance(aws_profile, str)
    session = boto3.session.Session(profile_name=aws_profile)
    client = session.client(service_name="mwaa")
    return client


def _send_mwaa_cli_post_request(
    mwaa_cli_token: Dict[str, str], mwaa_cli_command: str
) -> str:
    """
    Send a post to the AWS MWAA CLI which executes an Airflow command on our
    behalf. Docs available at:
    https://docs.aws.amazon.com/mwaa/latest/userguide/airflow-cli-command-
    reference.html.

    :param mwaa_cli_token: token consisting of CliToken and WebServerHostName parts
     generated by boto3 MWAA client create_cli_token()
    :param mwaa_cli_command: Airflow command to execute, i.e. 'dags list -o json'
    """
    mwaa_auth_token = "Bearer " + mwaa_cli_token["CliToken"]
    mwaa_webserver_hostname = (
        f"https://{mwaa_cli_token['WebServerHostname']}/aws_mwaa/cli"
    )
    mwaa_response = requests.post(
        mwaa_webserver_hostname,
        headers={
            "Authorization": mwaa_auth_token,
        },
        data=mwaa_cli_command,
    )
    _LOG.info(
        "POST Request: %s, status code: %s",
        mwaa_response.url,
        mwaa_response.status_code,
    )
    if mwaa_response.status_code != 200:
        mwaa_std_err_message = base64.b64decode(
            mwaa_response.json()["stderr"]
        ).decode("utf8")
        raise ValueError(mwaa_std_err_message)
    mwaa_std_out_message = base64.b64decode(
        mwaa_response.json()["stdout"]
    ).decode("utf8")
    return mwaa_std_out_message


def _clear_long_running_tasks(
    dags_list: List[str],
    dag_duration_threshold: int,
    mwaa_cli_token: Dict[str, str],
) -> None:
    """
    Iterate through list of active DAGs and clear tasks which have Run
    Important note, DAG "run" time attribute is not the same time as "started"
    time. i.e. A DAG can have Run set to: 2022-04-28 14:05:00 UTC but and
    Started: 2022-04-28 14:06:40.

    :param dags_list: list of DAGs to iterate through
    :param dag_duration_threshold: Max allowed DAG Task run time, tasks
     with duration time above the threshold get cleared.
    :param mwaa_cli_token: token consisting of CliToken and WebServerHostName parts
     generated by boto3 MWAA client create_cli_token()
    """
    hdbg.dassert_lte(1, dag_duration_threshold)
    start_datetime = datetime.datetime.now(
        datetime.timezone.utc
    ) - datetime.timedelta(seconds=dag_duration_threshold)
    # Enforce Airflow required format of datetime argument.
    start_datetime = start_datetime.strftime("%Y-%m-%dT%H:%M:%S+00:00")
    for dag in dags_list:
        _LOG.info(
            "Clearing %s if task run started before %s", dag, start_datetime
        )
        # Clear all RUNNING DAGs which have RUN attribute earlier than: now - threshold.
        # There is a bug in the CLI implementation, use --end-date but apply start_date value.
        mwaa_cli_command = f"tasks clear -y -u -d --only-running --end-date {start_datetime} {dag}"
        try:
            mwaa_std_out_message = _send_mwaa_cli_post_request(
                mwaa_cli_token, mwaa_cli_command
            )
            _LOG.info(mwaa_std_out_message)
        except ValueError as e:
            _LOG.warning("Clearing DAG Tasks of %s failed: %s", dag, str(e))


_LOG = logging.getLogger(__name__)


def _parse() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(
        description=__doc__,
        formatter_class=argparse.RawTextHelpFormatter,
    )
    parser = hparser.add_verbosity_arg(parser)
    parser.add_argument(
        "--mwaa_environment",
        action="store",
        required=True,
        type=str,
        help="Name of MWAA Environment to search in",
    )
    parser.add_argument(
        "--dag_duration_threshold",
        action="store",
        required=True,
        type=int,
        help="Max allowed duration (in seconds) for DAGs, Tasks in DAGs running \
            longer than this threshold will get cleared to unblock worker assigned to it",
    )
    parser.add_argument(
        "--test",
        action="store_true",
        help="If specified, only dags with prefix 'test_' get cleared, else \
            all active DAGs get cleared",
    )
    return parser  # type: ignore[no-any-return]


def _main(parser: argparse.ArgumentParser) -> None:
    args = parser.parse_args()
    hdbg.init_logger(verbosity=args.log_level, use_exec_path=True)
    client = _get_mwaa_client()
    if args.test:
        _LOG.info("Executing test run.")
    mwaa_cli_token = client.create_cli_token(Name=args.mwaa_environment)
    # Get list of all DAGS.
    mwaa_cli_command = "dags list -o json"
    mwaa_std_out_message = _send_mwaa_cli_post_request(
        mwaa_cli_token, mwaa_cli_command
    )
    dags_list = json.loads(mwaa_std_out_message)
    # Filter only active (unpaused DAGs).
    dags_list = filter(lambda x: x["paused"] == "False", dags_list)
    dags_list = map(lambda x: x["dag_id"], dags_list)  # type: ignore[no-any-return]
    if args.test:
        dags_list = filter(lambda x: x.startswith("test_"), dags_list)
    _clear_long_running_tasks(
        list(dags_list), args.dag_duration_threshold, mwaa_cli_token
    )


if __name__ == "__main__":
    _main(_parse())
